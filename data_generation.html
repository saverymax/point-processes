<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Thinned Nonhomogenous Poisson Processes for Presence-Only data - 3&nbsp; Presence-only data generation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./theory.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Presence-only data generation</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Thinned Nonhomogenous Poisson Processes for Presence-Only data</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Welcome</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./introduction.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./theory.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Poisson process theory</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./data_generation.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Presence-only data generation</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Presence-only data generation</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Having introduced some theory for Poisson Point Process models, we next move on to data simulation. Here we simulate some presence-only data, in preparation to fit a nonhomogenous poisson process model. We specify the intensity for each site, the total number of individuals, the area of each site (assumed to be 1 here), and the sampling bias.</p>
<p>Following Fithian 2015, each observation <span class="math inline">\(i\)</span> is associated with a site <span class="math inline">\(s_i\)</span> area <span class="math inline">\(D\)</span>. For each site <span class="math inline">\(s_i\)</span>, there are associated covariates <span class="math inline">\(x_i = x(s_i)\)</span> and <span class="math inline">\(z_i = z(s_i)\)</span>. For each survey site, <span class="math inline">\(s_i\)</span> represents the centroid of a quadrat Ai. This is an essential assumption in our model, where we will use the Poisson likelihood to for the number of counts in each quadrat. At <span class="math inline">\(s_i\)</span> we observe counts <span class="math inline">\(N_{i} = N_{}(A_i)\)</span> or binary presence/absence indicators <span class="math inline">\(y_{i}\)</span>, with <span class="math inline">\(y_{i} = 1\)</span> if <span class="math inline">\(N_i &gt; 0\)</span> and <span class="math inline">\(y_i = 0\)</span> otherwise.</p>
<p>One issue in generating the data is that in using a poisson model to simulate the counts for each site, we lose individual point information in aggregating the points to counts per quadrat. However, this issue of aggregation is unavoidable, because we are using covariates that correspond to each cell. This is an important point. The assumptions we make about the grid will actually effect the way we simulate data. For example, when the only covariate data we have is that which is associated with the quadrat we are working with, then to simulate the data, each point realization will be created in aggregate, that is, a draw from a poisson distribution characterized by an functional of intensity dependent only on the covariates.</p>
<p>If our covariates exist on a finer scale than the quadrat, we can simulate the point locations more finely as well, and take a simulation approach outlined on page 2020 of Banerjee 2014 and followed by Koshkina, 2017. In this approach, we simulate first the total number of observations, create a homogenous poisson process, and then thin the process at the level of the grid of covariates we are working with. It doesn’t completely make sense to simulate PPP data in this way here, because our covariates only exist at the level of the aggregated quadrat. That is, we assume that the intensity is constant across our region <span class="math inline">\(A\)</span>, because according to our true data generating process, it is. This is also convenient for the approximation we are using.</p>
<p>We must also take into account the bias associated with the observation of species with true intensity <span class="math inline">\(\lambda(s)\)</span>. In order to account for the bias caused by collecting presence-only observations, the poisson process is thinned by the sampling bias <span class="math inline">\(b\)</span>. For more information about thinning a poisson process, see https://math.stackexchange.com/questions/580883/thinning-a-poisson-process <span class="math display">\[
\lambda(s) = \theta(s)b(s) = \exp[\alpha + \beta'x(s) + \gamma + \delta'z(s)].
\]</span> The question of the data generating process under our modelling assumptions is an interesting one. Referencing our initial theoretical outline, we need to simulate points with likelihood <span class="math display">\[
\prod_i\lambda(s_i)\frac{\exp(-\lambda(D))}{n!}.
\]</span> In the homogenous case, we can simulate <span class="math inline">\(n\)</span> observations from <span class="math display">\[
N(D) \sim Poisson(\lambda|D|),
\]</span> (<span class="math inline">\(\lambda(s)=\lambda\)</span>, and is thus constant over <span class="math inline">\(D\)</span>), and then according to the <span class="math inline">\(n\)</span>, distribute these uniformly over <span class="math inline">\(D\)</span>. In the case of the Nonhomogenous Poisson Process, we can do the same, drawing <span class="math inline">\(n\)</span> now from <span class="math inline">\(N(D) \sim Poisson(\lambda(D)) = Poisson(\int_D\lambda(s)ds)\)</span>, and then distributing their locations over <span class="math inline">\(D\)</span>. Instead of uniformly distributing them however, they are placed according to the distribution <span class="math inline">\(\frac{\lambda(s)}{\lambda(D)}\)</span>. There are two issues here, both relating to the evaluation of the integral for the expected number of observations.</p>
<p>Remember that we are using as intensity <span class="math display">\[
\lambda(A_i) = \int_A\lambda(s)ds = \int_A\exp[\alpha + \beta'x(s)]ds = \exp[\alpha + \beta'x_i],
\]</span> because we only have information <span class="math inline">\(X_i\)</span> for quadrat <span class="math inline">\(A_i\)</span> centered around <span class="math inline">\(s_i\)</span>. While we are doing simulations, we could arbitrarily create a finer covariate grid but we won’t have access to this during the modelling process. Using the <span class="math inline">\(x_i\)</span> we have, both <span class="math inline">\(\lambda(A)\)</span> and <span class="math inline">\(\lambda(D)\)</span> will be approximations at the covariate resolution, using the assumption that each <span class="math inline">\(x_i\)</span> is constant over <span class="math inline">\(A_i\)</span>. This being the case, then for each observation, we will use the same distribution as the other points that fall into the same <span class="math inline">\(A_i\)</span>. That is, multiple points will have the same distribution <span class="math inline">\(\frac{\exp[\alpha + \beta'x_i]}{\sum_i \exp[\alpha + \beta'x_i]}\)</span>. This goes somewhat against the idea of distributing the points in continuous space. Therefore, given the independence of each <span class="math inline">\(A_i\)</span> conditional on the covariates, another approach is to generate counts for each <span class="math inline">\(A_i\)</span> and then uniformly distribute them within each <span class="math inline">\(A_i\)</span>. If <span class="math inline">\(x_i\)</span> is constant across <span class="math inline">\(A_i\)</span>, this is ok. However, if we cannot assume this, using the continuous probability distribution for each point <span class="math inline">\((\lambda(s)/\lambda(D))\)</span> is necessary to avoid the integral of <span class="math inline">\(\lambda(A)\)</span>. We can do so in a way that avoids computing <span class="math inline">\(\lambda(D)\)</span> as well (Banerjee, 2014. p220), by computing <span class="math inline">\(\lambda_{max}\)</span>, simulating <span class="math inline">\(n\)</span> from <span class="math inline">\(N(D) \sim Poisson(\lambda_{max}|D|)\)</span>, and the rejecting some of these points by <span class="math inline">\(\lambda(s_i)/\lambda_{max}\)</span>. In this way, the only thing we need is information at the level of <span class="math inline">\(\lambda(s_i\)</span>) and avoid <span class="math inline">\(\lambda(D)\)</span> and <span class="math inline">\(\lambda(A)\)</span>.</p>
<p>So note that we take the route of simulation depending on our available information. If we only have <span class="math inline">\(x_i\)</span> for each quadrat, directly generating the points as a poisson random variable is a good option because it avoids any complicated integrals. But if we have finer covariates than at the quadrat level we are working with, then thinning the process down with the approach of Banerjee and others is better because it also avoids the integrals and has finer resolution.</p>
<p>There are a few things to during the data gerating process with the NHPP. The area of the total space, <span class="math inline">\(|D|\)</span>, the area of each site (quadrat) <span class="math inline">\(|A_i|\)</span>, and the number of cells <span class="math inline">\(c\)</span> that <span class="math inline">\(D\)</span> is discretized into. The area of <span class="math inline">\(A\)</span> depends on the number of discretizations (or cells): <span class="math inline">\(|A_i| = |D|/c\)</span>. The intensity will be scaled by this factor <span class="math inline">\(|D|/c\)</span>, so that as the area of <span class="math inline">\(|A|\)</span> becomes smaller, the intensity converges to that of a “true” continuous poisson process with its center at <span class="math inline">\(A_i\)</span>. We also assume that the intensity is constant over <span class="math inline">\(A\)</span>, so that we can indeed scale the intensity by the area factor, instead of needing to integrate over <span class="math inline">\(A\)</span>. This assumption is in contrast to assuming that we model the instensity directly as <span class="math inline">\(\Lambda(A_i) = \exp(\beta'X)\)</span> (versus <span class="math inline">\(\Lambda(A_i) = \frac{|D|}{c}\exp(\beta'X)\)</span>).</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./theory.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Poisson process theory</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->



</body></html>