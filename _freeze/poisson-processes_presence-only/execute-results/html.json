{
  "hash": "a1c0f4047aee49f9d86a1e7cc5a004d7",
  "result": {
    "markdown": "# Simulation and modelling\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(hrbrthemes)\nlibrary(cmdstanr) \nlibrary(bayesplot)\nlibrary(spatstat)\nlibrary(dplyr)\nlibrary(tidyr)\n\nsource(\"presence_only_functions.R\")\nsource(\"surface_functions.R\")\n```\n:::\n\n## Implementation\n\nThe previous sections discussed the theoretical and practical aspects of data generation. We now proceed to implement the data generation procedure. We first generate observations at each site and create plots of observed intensities, bias, and counts. We then fit a Poisson Point Process to the generated data.\n\nWe create a ring-shaped environment based on two correlated covariates and generate PO points accordingly.\n\n::: {.cell}\n\n```{.r .cell-code}\narea_D <- 100\nk <- 20\nsites <- k^2\n# Parameter values somewhere around Fithian 2015.\nalpha <- -2 \nbeta <- 2\ngamma <- -2\ndelta <- 0.5\nparams <- list(alpha=alpha, beta=beta, gamma=gamma, delta=delta)\naux_cor <- 0.7\ngrid_points <- get_sampling_surface_donut(k)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/data-gen-1.png){width=672}\n:::\n\n```{.r .cell-code}\ngrid_points <- get_bias_surface_correlated(grid_points, aux_cor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Correlation between X and Z\"\n          [,1]      [,2]\n[1,] 1.0000000 0.8318977\n[2,] 0.8318977 1.0000000\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/data-gen-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsites <- sites/4\ngrid_points <- grid_points %>% dplyr::filter(x<(k/2)+1, y<(k/2)+1)\n# Filter for only a quarter of the grid.\n# If we filter, we need to change the total sites as well\n# Need distances for LGCP\ndistance_mat <- as.matrix(dist(grid_points[,1:2]))\ndata_reps <- 1\ncorr_matrix <- specify_corr(grid_points[,1:2])\ngp_bool <- F\nsim_data <- generate_ppp_data_r(grid_points, params, sites, data_reps, corr_matrix, gp_bool, area_D)\nY_positive_indices <- which(sim_data$Y>0)\nstopifnot(sum(sim_data$Y[Y_positive_indices]) == nrow(sim_data$coordinates))\nsim_data$Y_coords\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           x         y\n1   8.875951  1.773338\n2   8.418654  2.586547\n3   7.682086  2.968490\n4   9.443523  2.937034\n5   9.232656  3.004253\n6   9.419722  3.417642\n7   9.369643  2.645977\n8  10.242691  3.446854\n9  10.425511  3.301856\n10  9.850484  2.680007\n11  5.661172  4.209399\n12  6.244311  4.384666\n13  6.620891  3.542528\n14  6.521558  3.645729\n15  9.643957  3.970256\n16  4.693362  4.684367\n17  5.261157  4.808354\n18  7.162766  4.505626\n19  4.276170  5.821939\n20  3.873761  5.525741\n21  4.134683  6.405719\n22  1.843085  7.150085\n23  2.543938  7.697512\n24  2.708596  7.552906\n25  2.873088  9.258479\n26  2.668776  8.519745\n27  3.293108  8.620217\n28  2.620333 10.064382\n29  3.022244  9.757110\n30  3.112645 10.053107\n```\n:::\n\n```{.r .cell-code}\ngrid_points[Y_positive_indices,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    x  y      aux_x       aux_z\n19  9  2  0.3425419  0.25429287\n28  8  3  1.7474542  2.01497588\n29  9  3  2.2578390  1.58412306\n30 10  3  2.3263479  1.22750804\n36  6  4  1.9218166  1.24545874\n37  7  4  1.7189159  1.11232836\n40 10  4  0.4314067 -0.43573796\n45  5  5  2.2578390  2.30065458\n47  7  5  0.1949836  0.02354021\n54  4  6  1.9218166  2.54440191\n62  2  7 -0.2854436 -0.59967665\n73  3  8  1.7474542  1.04834902\n83  3  9  2.2578390  1.26880450\n93  3 10  2.3263479  2.20702428\n```\n:::\n:::\n\nThe above output shows the exact location of the generated points and the associated $x$ and $z$ covariate values.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use the final generation iteration\np <- ggplot(grid_points, aes(x, y, fill=sim_data$lambda[data_reps,])) + \n  geom_tile() +\n  scale_fill_viridis(discrete=FALSE) +\n  ggtitle(\"Generated intensity per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/gen-plot-1.png){width=672}\n:::\n\n```{.r .cell-code}\np <- ggplot(grid_points, aes(x, y, fill=sim_data$bias[data_reps,])) + \n  geom_tile() +\n  scale_fill_viridis(discrete=FALSE) +\n  ggtitle(\"Generated bias per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/gen-plot-2.png){width=672}\n:::\n\n```{.r .cell-code}\nthinned_intensity <- sim_data$lambda[data_reps,]*sim_data$bias[data_reps,]\np <- ggplot() +\n  geom_tile(grid_points, mapping=aes(x, y, fill=thinned_intensity, width=1, height=1), alpha=.6) + \n  scale_fill_viridis(discrete=FALSE, name=\"L*b\") +\n  ggtitle(\"Generated thinning per site, including generated (or observed) individuals\") +\n  geom_point(data=sim_data$Y_coords, mapping=aes(x=x, y=y), size=3, col=\"white\") +\n  theme(panel.grid.minor = element_line(colour=\"white\")) +\n  scale_y_continuous(breaks = seq(0, 20, 1)) +\n  scale_x_continuous(breaks = seq(0, 20, 1)) \nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/gen-plot-3.png){width=672}\n:::\n:::\n\nThe above plots show the PO points and the ring-shaped surface.\n\n\n\n\nNext we fit the Thinned Nonhomogeneous Poisson Process model in Stan. We can make a few observations about this model. First, examine the likelihood: \n$$L(\\lambda|Y) = \\prod^{N}_{i=1}\\frac{\\lambda_i^{n_i}\\exp[-\\lambda_i]}{n_i!}$$. This is made using  the assumption that the counts at sites $s_i$ are distributed following a poisson process with mean $\\lambda$. This assumption allows for a simpler specification of the likelihood, since we can use the poisson distribution. The setting of $|A|=1$ allows us to make this assumption, as we do not need to multiple the intensity parameter $\\lambda$ by the area in the model.\n\nThe next sections of code fitting and diagnosing the poisson process model in Stan, using the generated data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_string <- stan_poisson_process\nwrite(model_string, model_path)\n# data_reps is 1 here so just use the first index\ndata = list(N = sites, X = grid_points$aux_x, Z = grid_points$aux_z, y = sim_data$Y[data_reps,])\nmodel <- cmdstan_model(model_path)\nfit <- model$sample(data=data, seed=13, chains=3, iter_sampling=2000, iter_warmup=200)\n```\n:::\n\nThe above code fits the table. We next examine the fit.\n\n::: {.cell}\n\n```{.r .cell-code}\nfit$summary(variables=c('alpha', 'beta', 'gamma', 'delta'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 10\n  variable   mean median    sd   mad      q5   q95  rhat ess_bulk ess_tail\n  <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl> <dbl> <dbl>    <dbl>    <dbl>\n1 alpha    -1.36  -1.37  6.74  6.72  -12.5   9.67   1.00    1995.    2148.\n2 beta      1.81   1.81  0.386 0.372   1.18  2.45   1.00    2314.    2537.\n3 gamma    -1.42  -1.43  6.73  6.72  -12.5   9.73   1.00    2019.    2187.\n4 delta    -0.126 -0.119 0.377 0.382  -0.761 0.496  1.00    2401.    2583.\n```\n:::\n:::\n\nFrom the table above, we can observe that the parameters $\\beta$ and $\\delta$ have been recovered. However, due to the correlation of $\\alpha$ and $\\gamma$, only the sum $\\alpha+\\gamma$ can be correctly identified. Our \"true\" sum of was equal to -4, and we can see the estimate here is $~4.7$, which is reasonable given we incorporate priors and are estimating correlated parameters. The correlation between the two can be observed in the scatter plots below, as well as in the wide confidence interval of the posterior, relative to the other parameters.\n\n## Diagnostics\n\nHere we check goodness of fit and Posterior Predictive Checks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam_vec <- c('alpha', 'gamma', 'beta', 'delta')\nposterior <- fit$draws(variables=param_vec)\ncolor_scheme_set(\"mix-blue-pink\")\np_trace <- mcmc_trace(posterior,  pars = c(\"alpha\", \"beta\", \"gamma\", \"delta\"),\n                      facet_args = list(nrow = 2, labeller = label_parsed))\nprint(p_trace + facet_text(size = 15))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/diag-check-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot_title <- ggtitle(paste(\"Posterior distributions, with means and 90% interval\"))\np_post <- mcmc_areas(posterior,  prob = 0.9, point_est=\"mean\", regex_pars = c(\"alpha\", \"beta\")) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/diag-check-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot_title <- ggtitle(paste(\"Posterior distributions, with means and 90% interval\"))\np_post <- mcmc_areas(posterior,  prob = 0.9, point_est=\"mean\", regex_pars = c(\"gamma\", \"delta\")) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/diag-check-3.png){width=672}\n:::\n\n```{.r .cell-code}\nmcmc_intervals(posterior)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/diag-check-4.png){width=672}\n:::\n:::\n\nImportantly, note the wide credible intervals on $\\alpha$ and $\\gamma$. Why? See the scatter plots below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_title <- ggtitle(\"Parameter posterior sample correlation\")\np_post <- mcmc_pairs(posterior)\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/posterior-pp-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmcmc_scatter(posterior, pars=c('alpha','gamma'))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/posterior-pp-2.png){width=672}\n:::\n:::\n\nThere is near perfect correlation between $\\alpha$ and $\\gamma$, as expected.\n\n## PPD\n\nWe next look at the Posterior Predictive Distribution (PPD) of the observations per site. That is, we plot the generated counts $Y_i$ for site $s_i$ on the sampling surface (grid). \n\nThe PPD can be expressed as the samples from the predictive distribution of $Y$ taking into account the uncertainty surrounding the parameters. The PPD can be written as\n$$\np(\\tilde{y}|Y) = \\int p(\\tilde{y}|\\lambda, b, Y)p(\\lambda, b|Y) dbd\\lambda\n$$\n\nsuch that the posterior uncertainty of the parameters is integrated out.\n\nBelow we plot the generated values of $\\tilde{y}$ for each site. Additionally, the generated quantities of intensity, bias, and intensity*bias ($\\lambda\\cdot b) per site are also plotted on the grid. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerated_vars <- c('lambda_bias', 'lambda_rep', 'b_rep', 'y_rep')\nlambda_thinned <- fit$summary(variables=generated_vars[1])$mean\nlambda_rep <- fit$summary(variables=generated_vars[2])$mean\nbias_rep <- fit$summary(variables=generated_vars[3])$mean\ny_ppd <- fit$summary(variables=generated_vars[4])$mean\nppd_df <- data.frame(x=grid_points$x, y=grid_points$y, y_rep=y_ppd, lt=lambda_thinned, l=lambda_rep, b=bias_rep)\nhead(ppd_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y       y_rep          lt        l        b\n1 1 1 0.002000000 0.001857518 29666.24 243090.3\n2 2 1 0.001166667 0.001859585 29731.43 243665.1\n3 3 1 0.001666667 0.002067503 30430.25 263499.0\n4 4 1 0.001333333 0.002184711 34790.56 244657.8\n5 5 1 0.003500000 0.003014073 50946.62 245093.8\n6 6 1 0.005166667 0.005084997 90423.75 243710.1\n```\n:::\n:::\n\nIt is important to notice that while the thinned intensity is ostensibly realistic in estimation, the intensity and bias are not. This is due to the specification of the Thinned Poisson Process\n$$\\lambda^* = \\lambda(s)b(s)$$\nsuch that\n$$\\lambda^* = \\exp\\left[\\alpha + \\beta*X(s) + \\gamma + \\delta*Z(s)\\right]$$\n\nWe can then see the generated data in the sampling surface:\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(ppd_df, aes(x, y, fill=y_rep)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"PPD counts per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/viz-gen-1.png){width=672}\n:::\n\n```{.r .cell-code}\np <- ggplot(ppd_df, aes(x, y, fill=lt)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"Thinned intensity per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/viz-gen-2.png){width=672}\n:::\n\n```{.r .cell-code}\np <- ggplot(ppd_df, aes(x, y, fill=l)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"Intensity per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/viz-gen-3.png){width=672}\n:::\n\n```{.r .cell-code}\np <- ggplot(ppd_df, aes(x, y, fill=b)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"Bias per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/viz-gen-4.png){width=672}\n:::\n:::\n\nThe prediction of PO observatiosn at each site is realistic, as is the thinned intensity. But alone, the intensity and bias predictive disitributions are poorly estimated.\n\n\n## Correlation between coefficients \nIn the above plots, it seems that the bias and unthinned intensity are behaving strangely, even though the thinned intensity is generated as we would expect. This is a manifestation of the completely correlated parameters describing the behavior of the intensity and the bias. We can notice that the generated bias and intensity alone are both really large. The issue with the large values appears this way because we are taking the mean of the posterior distribution as our point estimate and showing that in the plot of the sites above. However, when we generate the thinned intensity, we multiply each draw from the posterior predictive chain together. So even though the mean of the posterior chain is high, the individual draws of the bias and intensity inversely fluctuate around each other, due the high correlation between the two parameters.\n\nWe take a look at the posterior intervals of the estimates to get a little better idea of this.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_title <- ggtitle(paste(\"Posterior distributions, with means and 90% interval\"))\np_post <- mcmc_intervals(fit$draws(),  prob = 0.9, point_est=\"mean\", regex_pars = generated_vars[1]) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-1-1.png){width=672}\n:::\n:::\n\nThe intervals shown above are for the thinned bias. These are relatively reasonable, as stated.\n\n::: {.cell}\n\n```{.r .cell-code}\np_post <- mcmc_intervals(fit$draws(),  prob = 0.9, point_est=\"mean\", regex_pars = generated_vars[2]) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 37 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-2-1.png){width=672}\n:::\n:::\n\nHowever, the intervals for the intensity (unthinned) are unrealistic, due to the unindentifiable parameters.\n\n::: {.cell}\n\n```{.r .cell-code}\np_post <- mcmc_intervals(fit$draws(),  prob = 0.9, point_est=\"mean\", regex_pars = generated_vars[3]) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 100 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-3-1.png){width=672}\n:::\n:::\n\nAnd finally, the intervals of the generated bias is also not correct.\n\nThen we look at the intervals and histograms of the posterior chains for just a few chains.\n\n::: {.cell}\n\n```{.r .cell-code}\n# The gen parameters for just a few of the sites\ngen_lambda <- c('lambda_rep[1]', 'lambda_rep[10]', 'lambda_rep[20]')\ngen_lb <- c('lambda_bias[1]', 'lambda_bias[10]', 'lambda_bias[20]')\ngen_b <- c('b_rep[1]', 'b_rep[10]', 'b_rep[20]')\np_post <- mcmc_intervals(fit$draws(),  prob = 0.9, point_est=\"mean\", pars = gen_lambda) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\np_post <- mcmc_intervals(fit$draws(),  prob = 0.9, point_est=\"mean\", pars = gen_b) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 3 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-4-2.png){width=672}\n:::\n\n```{.r .cell-code}\np_post <- mcmc_intervals(fit$draws(),  prob = 0.9, point_est=\"mean\", pars = gen_lb) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-4-3.png){width=672}\n:::\n\n```{.r .cell-code}\np_post <- mcmc_hist(fit$draws(), pars = gen_lambda) \nprint(p_post)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-4-4.png){width=672}\n:::\n\n```{.r .cell-code}\np_post <- mcmc_hist(fit$draws(), pars = gen_b)\nprint(p_post)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-4-5.png){width=672}\n:::\n\n```{.r .cell-code}\np_post <- mcmc_hist(fit$draws(), pars = gen_lb) \nprint(p_post)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/pp-correlation-4-6.png){width=672}\n:::\n\n```{.r .cell-code}\n# Look at counts for each site\n#gen_y <- c(\"y_rep[1]\", \"y_rep[10]\", \"y_rep[20]\")\n#p_post <- mcmc_hist(fit$draws(), pars=gen_y)\n#print(p_post)\n```\n:::\n\nFrom this we notice that the intervals for some of the generated lambdas and biases are wide, but not for the thinned values. But even for those that have wide intervals, nearly all of the chain values in the histograms are the same. This is because it's only a few values that cause the mean to be biased, due to the correlation of the parameters.\n\nThe take away is that the mean for the generated quantities is very skewed by the occassional large value. This high skew is caused by the correlation between b and l, since these parameters are not estimable between themselves. Therefore, we arrive at reasonable estimates  for b*l since this is draw specific (where when one is high the other is low), but  the overall mean for either b or l over multiple draws cannot be trusted. This is clear from the histograms of $\\lambda$ and the bias, where most of the values take on very low values, but do fluctuate higher. And when one goes higher, the other goes lower, which I'd like to check a specific example of, for one draw.\n\n## Diagnostics\nFinally, it is possible to look at a variety of NUTS diagnostics metrics. I am not going to go into much detail here.\n\n::: {.cell}\n\n```{.r .cell-code}\nnuts_fit <- nuts_params(fit)\nmcmc_parcoord(fit$  draws(), np=nuts_fit)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/nuts-diag-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmcmc_nuts_divergence(nuts_fit, log_posterior(fit))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/nuts-diag-1-2.png){width=672}\n:::\n:::\n\nThe parcord plot shows 1 line per iteration of the sampler. We can see the values each sampled parameter takes on, which allows us to notice the extent that correlation has on the sampled values. If there are any divergences in the sampling, these will show up in red and help us to pick out the parameters that may be contributing. to this.\n\nThere are no divergences so we don't need to worry.\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_rhat(rhat(fit))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/nuts-diag-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmcmc_neff(neff_ratio(fit))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/nuts-diag-2-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#mcmc_nuts_energy(nuts_fit, binwidth=1/2)\n#mcmc_nuts_acceptance(nuts_fit,  log_posterior(fit))\n```\n:::\n\nR hat, which compares between and within chain estimates, looks good.\n\n\"neff\" is the effective sample size estimates the number of independent samples, after accounting for autocorrelation in the chains. The figure here shows there are a reasonable number of independent samples, though the threshold is somewhat arbitrary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_acf(fit$draws(), pars=c('alpha', 'beta', 'gamma', 'delta'))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/auto-corr-1.png){width=672}\n:::\n:::\n\nAutocorrelation in the chains looks well-handled.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit$cmdstan_diagnose()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProcessing csv files: C:/Users/msavery/AppData/Local/Temp/RtmpG2BpUK/thinned_poisson_process-202405241050-1-52106e.csv, C:/Users/msavery/AppData/Local/Temp/RtmpG2BpUK/thinned_poisson_process-202405241050-2-52106e.csv, C:/Users/msavery/AppData/Local/Temp/RtmpG2BpUK/thinned_poisson_process-202405241050-3-52106e.csv\n\nChecking sampler transitions treedepth.\nTreedepth satisfactory for all transitions.\n\nChecking sampler transitions for divergences.\nNo divergent transitions found.\n\nChecking E-BFMI - sampler transitions HMC potential energy.\nE-BFMI satisfactory.\n\nEffective sample size satisfactory.\n\nSplit R-hat values satisfactory all parameters.\n\nProcessing complete, no problems detected.\n```\n:::\n\n```{.r .cell-code}\n# Leave loo out.\n#loo_results <- fit$loo(variables=\"lp__\", cores=4)\n#print(loo_results)\n```\n:::\n\nIt appears we have no additional problems in the models according the the Stan diagnostics.\n\n## LGCP\n\nWe next move on to incorporating spatial correlation. To do so, we fit a Log Gaussian Cox Process (LGCP). Where before we specified the intensity as\n$$\n\\lambda(s) = \\theta(s)b(s) = \\exp[\\alpha + \\beta'x(s) + \\gamma + \\delta'z(s)]\n$$\nwe now add a Gaussian process to incorporate spatial correlation between sites\n$$\n\\lambda(s) = \\theta(s)b(s) = \\exp[\\alpha + \\beta'x(s) + \\gamma + \\delta'z(s) + w(s)]\n$$\nso that the expected value for quadrat $A$ will be the integral over the quadrat:\n$$\n\\Delta(A) = \\int_A\\lambda(s)ds = \\int_A \\exp[\\alpha + \\beta'x(s) + \\gamma + \\delta'z(s) + w(s)]ds\n$$\nWe make the same approximations as before based on our limited covariate resolution. \n\nWhile the topic of LGCPs on its own is quite interesting and deserves its own treatment, for now we examine its behavior only as an adjustment to the NHPP. In a future post I will discuss approximations to the LGCP, which are quite important as fitting the spatial correlation matrix is computationally intensive as the number of locations increases. If we want to apply the LGCP to developing optimal designs (another future topic), we will need an approximation.\n\nFor now, I proceed with fitting the model in Stan.\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_string <- log_gaussian_cox_process\nwrite(model_string, model_path)\n# Here we need to use the distance matrix\ndata = list(N = sites, X = grid_points$aux_x, Z = grid_points$aux_z, y = sim_data$Y[data_reps,], D = distance_mat)\nmodel <- cmdstan_model(model_path)\nlgcp_fit <- model$sample(data=data, seed=13, chains=3, iter_sampling=2000, iter_warmup=200, thin = 10)\n```\n:::\n\n\nHaving fit the LGCP we can examine the parameters\n\n::: {.cell}\n\n```{.r .cell-code}\nlgcp_fit$summary(variables=c('alpha', 'beta', 'gamma', 'delta'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 10\n  variable    mean  median    sd   mad     q5    q95  rhat ess_bulk ess_tail\n  <chr>      <dbl>   <dbl> <dbl> <dbl>  <dbl>  <dbl> <dbl>    <dbl>    <dbl>\n1 alpha    -1.20   -1.19   0.746 0.800 -2.39  0.0364 1.00      636.     599.\n2 beta      1.49    1.50   0.361 0.352  0.889 2.08   0.999     612.     602.\n3 gamma    -1.20   -1.25   0.753 0.794 -2.40  0.0336 1.00      536.     447.\n4 delta     0.0336  0.0490 0.371 0.394 -0.587 0.622  1.00      642.     631.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nposterior <- lgcp_fit$draws()\ncolor_scheme_set(\"mix-blue-pink\")\np_trace <- mcmc_trace(posterior,  pars = c(\"alpha\", \"beta\", \"gamma\", \"delta\"),\n                      facet_args = list(nrow = 2, labeller = label_parsed))\nprint(p_trace + facet_text(size = 15))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/lgcp-chains-1.png){width=672}\n:::\n:::\n\nThe chains don't look perfect and it would probably be better to run the sampling algorithm for longer. But for now this is ok.\n\nThen check the posterior intervals:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_title <- ggtitle(paste(\"Posterior distributions, with means and 90% interval\"))\np_post <- mcmc_areas(posterior,  prob = 0.9, point_est=\"mean\", regex_pars = c(\"alpha\", \"beta\")) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/lgcp-ints-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot_title <- ggtitle(paste(\"Posterior distributions, with means and 90% interval\"))\np_post <- mcmc_areas(posterior,  prob = 0.9, point_est=\"mean\", regex_pars = c(\"gamma\", \"delta\")) + plot_title\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/lgcp-ints-2.png){width=672}\n:::\n\n```{.r .cell-code}\nmcmc_intervals(posterior, pars=c('alpha', 'beta', 'gamma', 'delta'))\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/lgcp-ints-3.png){width=672}\n:::\n\n```{.r .cell-code}\n#mcmc_hist(fit$draws(), pars = c('alpha', 'beta', 'gamma', 'delta')) \nplot_title <- ggtitle(\"Parameter posterior sample correlation\")\np_post <- mcmc_pairs(posterior, pars=c('alpha', 'beta', 'gamma', 'delta'))\nprint(p_post)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/lgcp-ints-4.png){width=672}\n:::\n:::\n\nInterestingly, the $\\alpha$ and $\\gamma$ parameters are somewhat identified. We can see that the parameters are nearly recovered, though biased slightly towards 0.\nAdditionally, The credible intervals are much smaller than in the Poisson point process, indicating that the parameters are indentifiable, though the scatter plots still show some correlation.\n\nFinally we take a look at the posterior predictions for $\\lambda$, $b$, and $\\lambda\\cdot b$.\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerated_vars <- c('lambda_bias', 'lambda_rep', 'b_rep', 'y_rep')\nlambda_thinned <- lgcp_fit$summary(variables=generated_vars[1])$mean\nlambda_rep <- lgcp_fit$summary(variables=generated_vars[2])$mean\nbias_rep <- lgcp_fit$summary(variables=generated_vars[3])$mean\ny_ppd <- lgcp_fit$summary(variables=generated_vars[4])$mean\nppd_df <- data.frame(x=grid_points$x, y=grid_points$y, y_rep=y_ppd, lt=lambda_thinned, l=lambda_rep, b=bias_rep)\np <- ggplot(ppd_df, aes(x, y, fill=y_rep)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"PPD counts per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/ppd-lgcp-1.png){width=672}\n:::\n\n```{.r .cell-code}\np <- ggplot(ppd_df, aes(x, y, fill=lt)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"Thinned intensity per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/ppd-lgcp-2.png){width=672}\n:::\n\n```{.r .cell-code}\np <- ggplot(ppd_df, aes(x, y, fill=l)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"Intensity per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/ppd-lgcp-3.png){width=672}\n:::\n\n```{.r .cell-code}\np <- ggplot(ppd_df, aes(x, y, fill=b)) + \n    geom_tile() +\n    scale_fill_viridis(discrete=FALSE) +\n    ggtitle(\"Bias per site\")\nprint(p)\n```\n\n::: {.cell-output-display}\n![](poisson-processes_presence-only_files/figure-html/ppd-lgcp-4.png){width=672}\n:::\n:::\n\nThis time, we get realistic estimates of $b$ and $\\lambda$, before thinning. Inducing the correlation structure allows us to better recover the parameters, albeit at a high computational cost. \n\nHaving fit the Poisson Process and LGCP to to simulated PO data and observed the behavior of each model, we have met the goal we set out to accomplish. Hopefully this can serve as a useful resource to anyone interested the topic.\n\n",
    "supporting": [
      "poisson-processes_presence-only_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}